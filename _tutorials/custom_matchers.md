---
# This file was generated by locco from _tutorials/src/custom_matchers.js. Do not edit it directly!
layout: tutorial
redirect_from:
    - "/tutorials/custom_matcher"
include_docco: true
file_name: "custom_matchers"
---
<table class="docco" cellspacing="0" cellpadding="0">
  <tbody>
  <tr id="section-Often_a_project_will_want_to_encapsulate_custom_matching_code_for_use_across">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Often_a_project_will_want_to_encapsulate_custom_matching_code_for_use_across">&#182;</a>
      </div>
      <div>
        <p>Often a project will want to encapsulate custom matching code for use across
multiple specs. Here is how to create a Jasmine-compatible custom matcher.</p>
<p>A custom matcher at its root is a comparison function that takes an <code>actual</code>
value and <code>expected</code> value. This factory is passed to Jasmine, ideally in a
call to <code>beforeEach</code> and will be in scope and available for all of the specs
inside a given call to <code>describe</code>. Custom matchers are torn down between specs.
The name of the factory will be the name of the matcher exposed on the return
value of the call to <code>expect</code>.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %} {% endhighlight %}
    </td>
  </tr>
  <tr id="section-This_object_has_a_custom_matcher_named_toBeGoofy">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-This_object_has_a_custom_matcher_named_toBeGoofy">&#182;</a>
      </div>
      <div>
        <p>This object has a custom matcher named &quot;toBeGoofy&quot;.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}const customMatchers = { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Matcher_Factories">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Matcher_Factories">&#182;</a>
      </div>
      <div>
        <h2>Matcher Factories</h2>
<p>Custom matcher factories are passed a <code>matchersUtil</code> parameter, which has a
set of utility functions for matchers to use to perform tasks like
determining whether two objects are equal (see:
<a href="/api/edge/MatchersUtil.html"><code>MatchersUtil</code></a> for reference documentation).
By using <code>MatchersUtil</code> where appropriate, custom matchers can work with
<a href="http://localhost:4000/tutorials/custom_equality">custom equality testers</a>
and <a href="http://localhost:4000/tutorials/custom_object_formatters">custom object formatters</a>
without any extra effort.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    toBeGoofy: function (matchersUtil) { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_factory_method_should_return_an_object_with_a_compare_function_that">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_factory_method_should_return_an_object_with_a_compare_function_that">&#182;</a>
      </div>
      <div>
        <p>The factory method should return an object with a <code>compare</code> function that
will be called to check the expectation.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}        return { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-A_Function_to_compare">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-A_Function_to_compare">&#182;</a>
      </div>
      <div>
        <h2>A Function to <code>compare</code></h2>
<p>The compare function receives the value passed to <code>expect()</code> as
the first argument - the actual - and the value (if any) passed to
the matcher itself as second argument.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}            compare: function (actual, expected) { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-toBeGoofy_takes_an_optional_expected_argument,_so_define_it">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-toBeGoofy_takes_an_optional_expected_argument,_so_define_it">&#182;</a>
      </div>
      <div>
        <p><code>toBeGoofy</code> takes an optional <code>expected</code> argument, so define it
here if not passed in.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                if (expected === undefined) {
                    expected = '';
                }
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Result">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Result">&#182;</a>
      </div>
      <div>
        <h3>Result</h3>
<p>The <code>compare</code> function must return a result object with a <code>pass</code>
property that is a boolean result of the matcher. The <code>pass</code>
property tells the expectation whether the matcher was
successful (<code>true</code>) or unsuccessful (<code>false</code>). If the expectation
is called/chained with <code>.not</code>, the expectation will negate this
to determine whether the expectation is met.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                const result = {
                };
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-toBeGoofy_tests_for_equality_of_the_actual&#39;s_hyuk">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-toBeGoofy_tests_for_equality_of_the_actual&#39;s_hyuk">&#182;</a>
      </div>
      <div>
        <p><code>toBeGoofy</code> tests for equality of the actual&#39;s <code>hyuk</code>
property to see if it matches the expectation.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                result.pass = matchersUtil.equals(actual.hyuk,
                    "gawrsh" + expected);
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Failure_Messages">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Failure_Messages">&#182;</a>
      </div>
      <div>
        <h3>Failure Messages</h3>
<p>If left <code>undefined</code>, the expectation will attempt to craft
a failure message for the matcher. However, if the return
value has a <code>message</code> property it will be used for a failed
expectation.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                if (result.pass) { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_matcher_succeeded,_so_the_custom_failure_message">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_matcher_succeeded,_so_the_custom_failure_message">&#182;</a>
      </div>
      <div>
        <p>The matcher succeeded, so the custom failure message
should be present in the case of a negative expectation -
when the expectation is used with <code>.not</code>.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                    result.message = "Expected " + actual +
                        " not to be quite so goofy";
                } else { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_matcher_failed,_so_the_custom_failure_message_should">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_matcher_failed,_so_the_custom_failure_message_should">&#182;</a>
      </div>
      <div>
        <p>The matcher failed, so the custom failure message should
be present in the case of a positive expectation.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                    result.message = "Expected " + actual +
                        " to be goofy, but it was not very goofy";
                }
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Return_the_result_of_the_comparison">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Return_the_result_of_the_comparison">&#182;</a>
      </div>
      <div>
        <p>Return the result of the comparison.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                return result;
            }
        }
    }
};
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Custom_negative_comparators">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Custom_negative_comparators">&#182;</a>
      </div>
      <div>
        <h3>Custom negative comparators</h3>
<p>If you need more control over the negative comparison (the <code>not</code> case) than
the simple boolean inversion above, you can also have your matcher factory
include another key, <code>negativeCompare</code> alongside <code>compare</code>, for which the
value is a function to invoke when <code>.not</code> is used. This function/key is
optional.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %} {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Registration_and_Usage">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Registration_and_Usage">&#182;</a>
      </div>
      <div>
        <h3>Registration and Usage</h3>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}describe("Custom matcher: 'toBeGoofy'", function() { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Register_the_custom_matchers_with_Jasmine_All_properties_on_the_object">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Register_the_custom_matchers_with_Jasmine_All_properties_on_the_object">&#182;</a>
      </div>
      <div>
        <p>Register the custom matchers with Jasmine. All properties on the object
passed in will be available as custom matchers (e.g., in this case
<code>toBeGoofy</code>).</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    beforeEach(function() {
        jasmine.addMatchers(customMatchers);
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Once_a_custom_matcher_is_registered_with_Jasmine,_it_is_available_on_any">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Once_a_custom_matcher_is_registered_with_Jasmine,_it_is_available_on_any">&#182;</a>
      </div>
      <div>
        <p>Once a custom matcher is registered with Jasmine, it is available on any
expectation.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    it("is available on an expectation", function() {
        expect({
            hyuk: 'gawrsh'
        }).toBeGoofy();
    });

    it("can take an 'expected' parameter", function() {
        expect({
            hyuk: 'gawrsh is fun'
        }).toBeGoofy(' is fun');
    });

    it("can be negated", function() {
        expect({
            hyuk: 'this is fun'
        }).not.toBeGoofy();
    });
});
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Custom_async_matchers">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Custom_async_matchers">&#182;</a>
      </div>
      <div>
        <h2>Custom async matchers</h2>
<p>You can also create your own async matchers. These are like regular custom
matchers except that they are used with <code>expectAsync</code> rather than <code>expect</code>
and the <code>compare</code> function is asynchronous.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}const customAsyncMatchers = {
    toBeResolvedToGoofy: function (matchersUtil) {
        return { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-A_Function_to_compare">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-A_Function_to_compare">&#182;</a>
      </div>
      <div>
        <h2>A Function to <code>compare</code></h2>
<p>The compare function should return a promise that resolves to a
value like the one returned by a regular matcher&#39;s compare function.
That can be done by explicitly returning a promise, as shown here,
or by declaring the function <code>async</code>.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}            compare: function (actualPromise, expected) { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_expected_value_should_be_a_promise,_but_Jasmine_does_not">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_expected_value_should_be_a_promise,_but_Jasmine_does_not">&#182;</a>
      </div>
      <div>
        <p>The expected value should be a promise, but Jasmine does not
enforce that. It&#39;s a good idea to make sure custom async
matchers do something reasonable if a non-promise is passed
to <code>expectAsync</code>.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                if (!actualPromise ||
                        typeof actualPromise.then !== 'function') {
                    throw new Error(
                        'Expected toBeResolvedToGoofy to be called on ' +
                        'a promise.'
                    );
                }

                if (expected === undefined) {
                    expected = '';
                }
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_compare_function_returns_a_promise">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_compare_function_returns_a_promise">&#182;</a>
      </div>
      <div>
        <p>The <code>compare</code> function returns a promise.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                return actualPromise.then(function (actual) { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-The_result_is_the_same_as_for_regular_expectations">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-The_result_is_the_same_as_for_regular_expectations">&#182;</a>
      </div>
      <div>
        <p>The result is the same as for regular expectations.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}                    const result = {
                    };

                    result.pass = matchersUtil.equals(actual.hyuk,
                        "gawrsh" + expected);

                    if (result.pass) {
                        result.message = "Expected a promise not to resolve " +
                            "to something quite so goofy";
                    } else {
                        result.message = "Expected a promise to resolve " +
                            "to something goofy, but it was not very goofy";
                    }

                    return result;
                });
            }
        }
    }
};
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Registration_and_Usage">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Registration_and_Usage">&#182;</a>
      </div>
      <div>
        <h3>Registration and Usage</h3>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}describe("Custom async matcher: 'toBeResolvedToGoofy'", function() { {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Registration_works_the_same_as_with_regular_custom_matchers,_except_that">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Registration_works_the_same_as_with_regular_custom_matchers,_except_that">&#182;</a>
      </div>
      <div>
        <p>Registration works the same as with regular custom matchers, except that
you call <code>jasmine.addAsyncMatchers</code> to register the matcher and <code>expectAsync</code>
to use it.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    beforeEach(function() {
        jasmine.addAsyncMatchers(customAsyncMatchers);
    });
 {% endhighlight %}
    </td>
  </tr>
  <tr id="section-Once_a_custom_matcher_is_registered_with_Jasmine,_it_is_available_on_any">
    <td class="docs">
      <div class="pilwrap">
        <a class="pilcrow" href="#section-Once_a_custom_matcher_is_registered_with_Jasmine,_it_is_available_on_any">&#182;</a>
      </div>
      <div>
        <p>Once a custom matcher is registered with Jasmine, it is available on any
expectation.</p>

      </div>
    </td>
    <td class="code">
      {% highlight javascript %}    it("is available on an expectation", async function() {
        await expectAsync(Promise.resolve({
            hyuk: 'gawrsh'
        })).toBeResolvedToGoofy();
    });

    it("can take an 'expected' parameter", async function() {
        await expectAsync(Promise.resolve({
            hyuk: 'gawrsh is fun'
        })).toBeResolvedToGoofy(' is fun');
    });

    it("can be negated", async function() {
        await expectAsync(Promise.resolve({
            hyuk: 'this is fun'
        })).not.toBeResolvedToGoofy();
    });
});
 {% endhighlight %}
    </td>
  </tr>
  </tbody>
</table>
